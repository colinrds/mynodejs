# co 原理


>


## yield 后面常见的可以跟的类型

- promises
- array (parallel execution)
- objects (parallel execution)
- generator functions (delegation)


- 关于执行传入的generator函数接收参数的问题
```
let co = require('co')

co(function * (name) {
  console.log(name) // qianlongo
}, 'qianlongo')
```
从co函数的第二个参数开始，便是传入的generator函数可以接收的实参




- co 函数本身接收一个 generator 函数，并且 co 执行后返回的是 Promise
```
function co(gen) {
  var ctx = this;
  var args = slice.call(arguments, 1)

  // we wrap everything in a promise to avoid promise chaining,
  // which leads to memory leak errors.
  // see https://github.com/tj/co/issues/180
  return new Promise(function(resolve, reject) {
    if (typeof gen === 'function') gen = gen.apply(ctx, args);
    if (!gen || typeof gen.next !== 'function') return resolve(gen);

    // xxx
  });
}
```

>在Promise的内部，先执行了外部传入的gen,执行的结果如果不具备next属性(且要是一个函数)，  
就直接返回，并将执行成功回调resolve(gen),否则得到的是一个指针对象。







## 参考
- [走一步再走一步，揭开co的神秘面纱](https://github.com/qianlongo/resume-native/blob/master/co-analysis.md)

- [Co源码以及与Koa的深入理解](https://github.com/panyifei/Front-end-learning/blob/master/Nodejs/Nodejs%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9D%97/Co%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E4%B8%8EKoa%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.md)
